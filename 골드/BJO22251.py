# 치르보기 빌딩은 $1$층부터 $N$층까지 이용이 가능한 엘리베이터가 있다. 
# 엘리베이터의 층수를 보여주는 디스플레이에는 최대 $K$ 자리의 수가 보인다. 
# 수는 $0$으로 시작할 수도 있다. 
# $0$부터 $9$까지의 각 숫자가 디스플레이에 보이는 방식은 아래와 같다. 
# 각 숫자는 7개의 표시등 중의 일부에 불이 들어오면서 표현된다.



# 예를 들어 $K=4$인 경우에 $1680$층과 $501$층은 아래와 같이 보인다.

                  

# 빌런 호석은 치르보기 빌딩의 엘리베이터 디스플레이의 LED 중에서 최소 $1$개, 최대 $P$개를 반전시킬 계획을 세우고 있다. 
# 반전이란 켜진 부분은 끄고, 꺼진 부분은 켜는 것을 의미한다. 예를 들어 숫자 $1$을 $2$로 바꾸려면 총 5개의 LED를 반전시켜야 한다. 또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 $1$ 이상 $N$ 이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다. 치르보기를 사랑하는 모임의 회원인 당신은 호석 빌런의 행동을 미리 파악해서 혼쭐을 내주고자 한다. 현재 엘리베이터가 실제로는 $X$층에 멈춰있을 때, 호석이가 반전시킬 LED를 고를 수 있는 경우의 수를 계산해보자.



N,K,P,X = map(int,input().split())
X = str(X)
while len(X) < K:
    X = '0'+X
zero = [0,4,3,3,4,3,2,3,1,2]
one =  [4,0,5,3,2,5,6,1,5,4]
two =  [3,5,0,2,5,4,3,4,2,3]
three =[3,3,2,0,3,2,3,2,2,1]
four = [4,2,5,3,0,3,4,3,3,2]
five = [3,5,4,2,3,0,1,4,2,1]
six  = [2,6,3,3,4,1,0,5,1,2]
seven =[3,1,4,2,3,4,5,0,4,3]
eight =[1,5,2,2,3,2,1,4,0,1]
nine = [2,4,3,1,2,1,2,3,1,0]

num_arr = [zero,one,two,three,four,five,six,seven,eight,nine]

ans = 0
for i in range(1,N+1):
    t = str(i)
    while len(t) < K:
        t = '0'+t
    
    temp = 0
    check = 0
    for j in range(len(t)):
        temp += num_arr[int(t[j])][int(X[j])]
        if temp > P:
            check = 1
            break
    if check == 0:
        ans +=1
print(ans-1)